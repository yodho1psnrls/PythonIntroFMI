from abc import ABC, abstractmethod
# import numpy as np
import glm
from math import sin
from math import cos
from math import exp
from math import pi


# parametric used as a namespace
class Equation(ABC):
    def __init__(self):
        pass

    # linear image from 2d(uv) to 3d(point) space
    @abstractmethod
    def calc(uv: glm.vec2) -> glm.vec3:
        pass


class Shere(Equation):
    def __init__(self):
        pass

    def calc(self, uv: glm.vec2):
        u = 2 * pi * uv[0]
        v = 2 * pi * uv[1]
        return glm.vec3(
            sin(u)*cos(v),
            sin(u)*sin(v),
            cos(u),
        )


class Cone(Equation):
    def __init__(self):
        pass

    def calc(self, uv: glm.vec2):
        u = 2 * pi * uv[0]
        v = uv[1]
        return glm.vec3(
            (1.0 - v) * cos(u),
            (1.0 - v) * sin(u),
            v
        )


# https://math.libretexts.org/Bookshelves/Calculus/Supplemental_Modules_(Calculus)/Vector_Calculus/2%3A_Vector-Valued_Functions_and_Motion_in_Space/2.7%3A_Parametric_Surfaces
class FoldPaper(Equation):
    def __init__(self):
        pass

    def calc(self, uv: glm.vec2):
        u = 2 * pi * uv[0]
        v = 2 * pi * uv[1]
        return glm.vec3(
            sin(u),
            cos(v),
            exp(2*u**(1/3) + 2*v**(1/3))
        )


class HourGlass(Equation):
    def __init__(self):
        pass

    def calc(self, uv: glm.vec2):
        u = 2.0 * pi * uv[0]
        v = 2.0 * pi * uv[1]
        return glm.vec3(
            cos(u)*cos(v),
            cos(u)*sin(v),
            uv[0],  # u
        )


class Screw(Equation):
    def __init__(self):
        pass

    def calc(self, uv: glm.vec2):
        u = 2.0 * pi * uv[0]
        v = 2.0 * pi * uv[1]
        return glm.vec3(
            cos(u)*cos(v),
            cos(u)*sin(v),
            uv[1],  # v
        )

# ----------------------------------------------------------------- #

# https://www.reddit.com/r/threejs/comments/1jb12bm/a_gallery_of_parametric_surfaces_with_their/


